## 그리디 알고리즘
어떠한 문제가 있을때 단순 무식하게, **탐욕적**으로 문제를 푸는 알고리즘<br>
여기서 **탐욕적** 이란 말은 **현재 상황에서 지금 당장 좋은 것만 고르는 방법**을 의미한다.<br>

코딩 테스트에서 만나게 될 그리디 알고리즘의 문제 유형은 앞으로 다루게 될 알고리즘과 비교했을 때<br>
사전에 외우고 있지 않아도 풀 수 있을 가능성이 높은 문제 유형<br>

따라서 많은 유형을 접해보고 문제를 풀어보며 훈련을 해야한다.<br>
보통 코딩 테스트에서 출제되는 그리디 알고리즘 유형의 문제는 창의력<br>
즉, 문제를 풀기 위한 최소한의 아이디어를 떠올릴 수 있는 능력을 요구한다.<br>
다시말해 **특정한 문제를 만났을 때 단순히 현재상황에서 가장 좋아보이는 것만 선택해도 문제를 풀 수 있는지를 파악할 수 있어야 한다.**<br>

그리디 알고리즘은 기준에 따라 좋은 것을 선택하는 알고리즘이므로<br>
문제에서 **'가장 큰 순서대로', '가장 작은 순서대로'** 와 같은 기준을 알게 모르게 제시해준다.<br>
대체로 이 기준은 정렬 알고리즘을 사용했을 때 만족시킬 수 있으므로 그리디 알고리즘 문제는 자주 정렬 알고리즘과 짝을 이뤄 출제한다.<br>

이제 '거스름돈'문제를 예로 그리디 알고리즘을 설명하겠다.<br>
***
### 거스름돈

문제 설명<br><br>
당신은 음식점의 계산을 도와주는 점원이다.<br><br>
카운터에는 거스름돈으로 사용할 500원, 100원, 50원, 10원짜리 동전이 무한히 존재한다고 가정한다.<br><br>
손님에게 거슬러 줘야 할 돈이 N원일 때 거슬러 줘야 할 동전의 최소 개수를 구하라<br><br>
단, 거슬러 줘야 할 돈 N은 항상 10의 배수이다.<br><br>

테스트 케이스<br>
|N|answer|
|:---:|:---:|
|1260|6|
***
나의 풀이<br><br>
결국 최소 개수를 구하기 위해서는 가장 큰 코인의 사용을 우선으로 두어야 한다.<br>
따라서 코인의 종류가 담긴 리스트 c를 만들고 리스트의 인덱스용도인 p를 선언한다.<br>
그리고 N을 가장 큰 동전에서부터 차례로 나누고 각각의 몫을 더해주면 정답이 된다.
```python
def solution(N):
    c = [500,100,50,10]
    p =0
    answer = 0
    while N != 0:
        temp = N//c[p]
        N = N%c[p]
        p+=1
        answer +=temp

    return answer
```

문제 해설<br><br>
이 문제는 그리디 알고리즘을 이용해 풀 수 있는 대표적인 문제로 간단한 아이디어만 떠올리면 해결 가능하다.<br>
바로 그 아이디어가 **가장 큰 화폐 단위부터 돈을 거슬러 주는 것**이 된다.<br>

답안<br>
```python
def solution(N):
  count=0
  coin_types = [500,100,50,10]
  for coin in coin_types:
      count+= n // coin
      n%=coin
```

답안 코드를 보면 화폐의 종류만큼 반복을 수행해야 한다.<br>
따라서 화폐의 종류가 K개 라고 할 때 위 소스코드의 시간 복잡도는 O(K)가 된다.<br><br>
즉, 이 알고리즘의 시간 복잡도는 동전의 총 종류에만 영향을 받고, 거슬러 줘야 하는 금액의 크기와는 무관하다.<br>

### 그리디 알고리즘의 정당성

그리디 알고리즘을 모든 알고리즘 문제에 적용할 수 있는 것은 아니다.<br>
대부분의 문제는 그리디 알고리즘을 이용했을 때 '최적의 해'를 찾을 수 없을 가능성이 다분하다.<br>
하지만 거스름돈 문제에서 **'가장 큰 화폐 단위부터'** 돈을 거슬러 주는 것과 같이 <br>
**탐욕적**으로 문제에 접근했을 때 정확한 답을 찾을 수 있다는 보장이 있을 때는 매우 효과적이고 직관적이다.<br>

그리디 알고리즘으로 문제의 해법을 찾았을 때는 그 해법이 **정당**한지 검토해야 한다.<br>
특히나 위의 거스름돈 문제를 그리디 알고리즘으로 해결 할 수 있는 이유는<br>

**가지고 있는 동전 중에서 큰 단위가 항상 작은 단위의 배수이므로**<br>
**작은 단위의 동전을 종합해 다른 해가 나올 수 없기 때문이다.**<br>

예를 들어 800원을 거슬러 줘야 하는데<br>
화폐 단위가 500원, 400원, 100원인 경우를 생각해보자.<br>
이 경우에 그리디 알고리즘으로는 4개의 동전(500원+100원+100원+100원)을 거슬러 줘야 한다고 나오는데<br>
최적의 해는 2개의 동전(400원+400원)을 거슬러 주는 것이다.<br>
다시 말해 이 문제에서는 큰 단위가 작은단위의 배수 형태이므로 <br>
**가장 큰 단위의 화폐부터 가장 작은 단위의 화폐까지 차례대로 확인하여 거슬러 주는 작업만을 수행하면 된다**라는 아이디어는 정당하다.<br><br>
대부분의 그리디 알고리즘 문제에서는<br> 
**문제 풀이를 위한 최소한의 아이디어를 떠올리고 이것이 정당한지 검토할 수 있어야 답을 도출할 수 있다.**<br>

어떤 코딩 테스트 문제를 만났을 때, 바로 문제 유형을 파악하기 어렵다면 그리디 알고리즘을 의심하고<br>
문제를 해결할 수 있는 탐욕적인 해결법이 존재하는지 고민해보자.<br><br>

만약 오랜시간을 고민해도 그리디 알고리즘으로 해결 방법을 찾을 수 없다면<br>
그때는 이후의 장에서 다루게 될 다이나믹 프로그래밍이나 그래프 알고리즘 등으로 문제를 해결 할 수 있는지를 재차 고민해보는 것도 한 방법<br><br>

처음에 문제를 만났을 때는 다양한 아이디어를 고려해야 한다.<br>
위의 '거스름돈'문제를 예시로 들자면<br>
처음에 '10원짜리로만 모두 거슬러 주도록 코드를 작성하면 어떻게 되지?'라고 생각 할 수 있다.<br>
여기서 '10원짜리로만 모두 거슬러 주면 최적의 해를 구할수 없겠구나.'라는 문제점을 인식하게 되고<br>
계속해서 고민 해 나아가다가 **'500원짜리부터 거슬러서 가장 작은 10원짜리 까지 차례대로 거슬러 준다면 어떻게 될까?'** 라고 생각하고<br>
**'거스름돈 문제에서는 큰 단위가 항상 작은단위의 배수 형태이므로, 이렇게 하면 항상 최적의 해를 보장할 수 있겟구나'** 까지 떠올릴 수 있어야 한다.<br>















