## DFS
DFS는 Depth-First Search, 깊이 우선 탐색이라고 부르며, 그래프에서 깊은 부분을 우선적으로 탐색하는 알고리즘이다.

### 그래프의 구조
그래프의 기본 구조는 **노드**와 **간선**으로 표현되며 이 때 **노드**를 **정점**이라고도 말한다.

그래프 탐색이란 하나의 노드를 시작으로 다수의 노드를 방문하는 것을 말한다.

또한 노드가 간선으로 연결되어 있다면 '두 노드는 인접하다'라고 표현한다.

프로그래밍에서 그래프는 크게 2가지 방식으로 표현할 수 있는데 코딩 테스트에서는 이 두 방식 모두 필요하니 두 개념에 대해 바르게 알고 있도록 하자.

1. 인접행렬 : 2차원 배열로 그래프의 연결관계를 표현하는 방식
2. 인접리스트 : 리스트로 그래프의 연결관계를 표현하는 방식

다음의 그래프의 예시를 사용한다.
| |0|1|2|
|:---:|:---:|:---:|:---:|
|0|0|7|5|
|1|7|0|무한|
|2|5|무한|0|

여기서 '무한'은 해당 두 노드 사이가 연결되어 있지 않은 경우를 의미한다.

먼저 인접 행렬로 구현한다면
```python
INF = 9999999

graph = [
  [0,7,5],
  [7,0,INF],
  [5,INF,0]
]
print(graph)
```
이 될 것이며 예시로 graph[0][0]은 즉, 그래프에서 0노드에서 0노드로 이동한 비용을 의미하게 된다.

다음은 인접 리스트 방식이다.

``` python
graph = [[] for _ in range(3)]

graph[0].append((1,7)) # 노드 0에 연결된 정보(노드, 비용) 저장
graph[0].append((2,5))

graph[1].append((0,7)) # 노드 1에 연결된 정보(노드, 비용) 저장

graph[2].append((0,5)) # 노드 2에 연결된 정보(노드, 비용) 저장

```

이 두 방식의 차이를 보자면

메모리 측면에서는 인접행렬 방식은 모든 관계를 저장하므로 노득 개수가 많을수록 낭비가 심해지지만

이와 같은 특성때문에 인접 리스트 방식에 비해 정보를 얻는 속도가 빠르다.

그에 대한 예시로

노드 1과 노드 7이 연결되어 있는지 확인하려면 인접 행렬에서는 graph[1][7]이면 되지만 

인접 리스트 방식에서는 노드 1에 대한 인접리스트를 앞에서 부터 차례대로 확인해야한다.

따라서 특정한 노드와 연결된 모든 인접 노드를 순환해야 하는 경우, 인접리스트 방식이 인접 행렬 방식에 비해 메모리 공간의 낭비가 적다.


### DFS의 구현

DFS의 동작과정은 다음과 같다.

```
1. 탐색 시작 노드를 스택에 삽입하고 방문처리를 한다.
2. 스택의 최상단 노드에 방문하지 않은 인접 노드가 있다면 그 인접 노드를 스택에 넣고 방문 처리를 한다.
방문하지 않은 인접 노드가 없으면 스택에서 최상단 노드를 꺼낸다.
3. 2번의 과정을 더 이상 수행할 수 없을 때까지 반복한다.
```

따라서 DFS는 스택을 사용하는 알고리즘이기에 재귀함수를 이용했을 때 매우 간결하게 구현할 수 있다.

```python
def dfs(graph, v, visited):
  visited[v] = True
  print(v, end=' ')
  for i in graph[v]:
    if not visited[i]:
      dfs(graph, i, visited)
graph= [
  [],
  [2,3,8],
  [1,7],
  [1,4,5],
  [3,5],
  [3,4],
  [7],
  [2,6,8],
  [1,7]
]

visited = [False]*9

dfs(graph,1, visited)
```
컴퓨터 메모리 내부 스택에서 최대한 방문하지 않은곳을 집요하게 파고 들어간다.
그러다가 더이상 나아갈 수 없게 되면 return되며 스택에서 빠져나가게 되고
해당 함수를 호출한 곳으로 돌아가게 된다.
즉, 그 전 노드로 돌아가게 된다.


### BFS 의 구현

넓이 우선 탐색이며, 쉽게 말해 가까운 노드부터 탐색하는 알고리즘이다.

BFS 알고리즘의 구현 방식은 다음과 같다.
```
1. 탐색 시작 노드를 큐에 삽입하고 방문처리를 한다.
2. 큐에서 노드를 꺼내 해당 노드의 인접 노드 중에서 방문하지 않은 노드를 모두 큐에 삽입하고 방문처리를 한다.
3. 2번의 과정을 더 이상 수행할 수 없을 때까지 반복한다.
```

따라서 파이썬의 deque를 사용하여 쉽게 구현 할 수 있다.
```python
from collections import deque

def bfs(graph, v, visited):
  queue = deque()
  queue.append(v)
  visited[v] = True
  while queue:
    a = queue.popleft()
    print(a,end="")
    for i in graph[a]:
      if not visited[i]:
        queue.append(i)
        visited[i] = True
graph = [
  [],
  [2,3,8],
  [1,7],
  [1,4,5],
  [3,5],
  [3,4],
  [7],
  [2,6,8]
  [1,7]
]

visited=[False]*9

bfs(graph, 1, visited)

```

BFS와 DFS는 결국 맵과 같이 좌표를 사용해야 하는 문제에서 주로 사용된다

예를들어 3x3크기의 게임 판이 있다고 가정한다면

(1,1)에 해당하는 노드에서는 인접한 노드로 (2,1)과 (1,2)가 될 수 있다.

이렇게 코딩 테스트에서 2차원 배열 탐색문제가 나온다면 그래프로 바꾸어서 생각해보면 BFS와 DFS로 해결이 가능한 문제가 있다.
